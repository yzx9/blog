---
title: TCP协议
date: 2019-12-18 09:56:00
updated: 2019-12-18 09:56:00
categories:
  - Computer Science
  - Network
tags: 
  - Network
---

# TCP

Transmission Control Protocol，传输控制协议。TCP 属于传输层通信协议，基于TCP的应用层协议有: HTTP(s)，SMTP，FTP，Telnet 和 POP3等。

**优点**: 提供可靠传输，具有拥塞控制

**缺点**: 传输效率低，慢启动

## 特点

**面向连接**：使用 TCP 传输数据前，需先建立连接，传输完成后需释放连接。

**全双工通信**：建立 TCP 连接后，双方都可以发送数据

**可靠通信**：TCP协议保证数据不丢失，无差错，不重复且按序到达

**面向字节流**：数据以流的形式传输

> TCP 会将数据报文分为数据段(data segment)传输，但由于其可靠性，上层可将其视为字节流传输

## 报文格式

![TCP Header - 20 byte](./assets/tcp-header.jpg)

报文首部最小长度为20字节

**源端口，目的端口**：
表明发送端所使用的端口号和要连接的目标主机的端口号，不包含IP地址。

**序号（seq）**：
表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。
若该数据包是整个TCP连接中的第一个包（SYN包），则该值是随机生成的。

**确认号（ack）**：
表明本端TCP已经接收到的数据，其值表示期待对端发送的下一个字节的序号。
实际上告诉对方，在这个序号减1以前的字节已正确接收。
若该数据包是整个TCP连接中的第一个包（SYN包），则确认号一般为0。

**数据偏移**：
表示以32位（4字节）为单位的TCP分组头的总长度（首部长度），用于确定用户数据区的起始位置。
在没有可变内容的情况下，TCP头部的大小为20字节，对应该值为5。

**标志位**：
- 紧急标志位（URG）：开启时表明此数据包处于紧急状态应该优先处理
- 确认标志位（ACK）：开启时表明确认号有效，否则忽略确认号
- 推送标志位（PSH）：开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送，比如 telnet 的场景
- 复位标志位（RST）：开启时表明TCP连接出现连接出现错误，数据包非法拒绝连接
- 同步标志位（SYN）：开启时表明连接建立的标志
- 终止标志位（FIN）：开启时表明释放一个连接

**窗口大小**：
表明期望接受到的数据包字节数，用于拥塞控制。

**校验和**：
实现对TCP报文头以及数据区进行校验。

**紧急指针**：
在紧急状态下（URG打开），指出窗口中紧急数据的位置（末端）。

**选项（可变）**：
用于支持一些特殊的变量，比如最大分组长度(MSS)，然后将其填充为32 bit的整数倍。

## 有限状态机及状态变迁

![TCP State Machine](./assets/tcp-state-machine.jpg)

![TCP State Transition](./assets/tcp-state-transition.jpg)

## 三次握手

![TCP Shake hands](./assets/tcp-shake-hands.jpg)

**第一次握手**：
客户端向服务器发送请求连接报文，SYN=1，seq=x(随机值)，客户端进入 SYN_SEND 状态，同时打开定时器

**第二次握手**：
服务器向客户端回信，SYN=1，ACK=1，seq=y(随机值)，ack=x+1，服务器端进入 SYN-RCVD 状态

**第三次握手**：
客户端向服务器回信，SYN=0，ACK=1，seq=x+1，ack=y+1，此次握手可以携带数据

### 为什么需要第三次握手?

这主要是为了防止已失效的连接请求报文段突然又传送到了B(服务器端)，因而产生错误。所谓“已失效的连接请求报文段”是这样产生的：

**正常情况**

A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A共发送了两个连接请求报文段，其中第一个丢失，第二个到达了B，没有“已丢失的连接请求报文段”。

**异常情况**

A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才能到达B。

本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为A又发出了一次新的连接请求。于是又向A发出确认报文段，同意建立连接。

假定不采用三次握手，那么只要B发出确认，新的连接就建立了。由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的连接已经建立了，并一直等待A发来数据，B的许多资源就这样浪费了。

采用三次握手的方法可以防止上述异常现象的发生。

> **如果在规定时间内未收到回信**
> 
> 会重新发送SYN报文段。如果在几次重发后仍然没有得到服务器的SYN+ACK响应就会放弃，端口切换CLOSE状态，并报告上层。

### SYN Flood 攻击

syn flood 是一种经典的 ddos攻击手段，这里面用到了TCP 三次握手存在的漏洞。
在上面的图中，可以看到当服务端接收到 SYN 后进入 SYN-RECV 状态，此时的连接称为**半连接**，同时会被服务端写入一个**半连接队列**。

如果攻击者在短时间内不断的向服务端发送大量的 SYN 包而不响应，那么服务器的 半连接队列很快会被写满，从而导致无法工作。实现 syn flood 的手段，可以通过伪造源 IP 的方式，这样服务器的响应就永远到达不了客户端 (握手无法完成)，或通过设定客户端防火墙规则达到同样的目的。

对 syn flood 实现拦截是比较困难的，可以通过启用 syn_cookies 的方式实现缓解，但最好的办法是通过专业的防火墙来解决。

## 四次挥手

![TCP wave](./assets/tcp-wave.jpg)

### 为什么需要四次挥手?

当一方发送了FIN，则表示在这一方不再会有数据的发送，进入半关闭状态，但是仍需要接受对方发送的消息。

其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)，

而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。

### FIN_WAIT_2 状态一直未接受到 FIN 怎么办?

1。为实现全双工，TCP协议规定需要一直等待FIN才会进入`TIME_WAIT`，即使网线被剪短...
2。从Telnet，FTP，到Apache，Nginx，几乎所有的TCP服务的实现均遵循了收到客户端的FIN之后立即发送FIN这么一个不成文的事实，也就是说，对于主动关闭的一方，当它发送完FIN进入`FIN_WAIT_2`状态后，可以在预期的时间内收到对端的FIN从而进入TIMEWAIT状态
3。Linux 2.2 以上可以根据`tcp_fin_timeout`配置定时器时长，默认 60s，超时后并不会进入TIMEWAIT状态，也不会发送reset。而 Windows 下表现一致，但是会发送reset

### 为什么存在 TIME_WAIT 状态?

当客户端收到了对方的FIN时，会进入TIME_WAIT状态，需要等待 2MSL 以直到确认不会再有重传的数据包之后再进入CLOSED状态

这么做的原因主要是为了可靠的关闭连接。为了防止网络不稳定情况，比如: 发送给对方的ACK可能会无法及时收到，此时对方可能重传FIN过来，如果提前进入CLOSE则会返回RST而不是ACK，就会影响关闭流程。

如果频繁的主动关闭连接，可能会产生大量`TIME_WAIT`，由于`TIME_WAIT`的连接占用了一个句柄及少量内存(4K)，那么就有可能会影响其他连接的建立，

> MSL叫Max Segment Lifetime，也就是关于一个数据包在网络中传输的最大生命周期的预设。关于其时长，RFC 中有 `Arbitrarily defined to be 2 minutes.`

## 可靠传输

1。无差错
2。发送&接受效率匹配

### 自动重传请求协议 ARQ

**定义**
传输出现差错时，接收方自动请求发送方重传出错数据

**作用**
无差错传输

**确认机制**
1。发送方每发送一帧，都需要等待接收方应答信号
2。接收方每接受一帧，都需要反馈一个应答信号
3。若接收方不反馈应答信号，则发送方必需一直等待

**超时重传**
1。发送方发送帧后开启计时器
2。超时后重发该数据帧，直到发送成功为止

#### 停等式 ARQ (Stop and Wait)

发送窗口大小 = 1
接受窗口大小 = 1

#### 后退N帧协议 (连续ARQ协议)

发送窗口大小 > 1
接受窗口大小 = 1

##### 累计确认

收到多个数据分组后，只需对按序到达的最后一个分组确认

**优点**
实现简单

**缺点**
无法向发送方反馈所有正确接收到的分组信息

##### 后退N帧

## 拥塞控制

慢启动，拥塞避免，快速重传，快速恢复

## Q&A

### 为什么多个TCP可以连接同一端口，比如HTTP的80端口?

TODO

### RST 是什么，为什么会出现

RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：

- 向一个未被监听的端口发送数据
- 对方已经调用 close 关闭连接
- 存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭
- 某些请求发生了超时

RST 机制有时候也会被利用，做一些[端口扫描](https://nmap.org/man/zh/man-port-scanning-techniques.html)

## Exercises

1。A,B两台机器都正常工作,B机器未监听任何端口。如果A机器向B机器80端口发送SYN包,会收到何种类型的回包?

> RST包

2。TCP建立连接的过程采用三次握手，已知第三次握手报文的发送序列号为1000，确认序列号为2000，请问第二次握手报文的发送序列号和确认序列号分别为?

> 1999,1000
